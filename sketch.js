let sourceImage;
let artCanvas;                 // off-screen buffer for Mondrian art
let ready = false;             // track if art is ready

// Fixed design space
const DESIGN_W = 1920;         // virtual design width
const DESIGN_H = 1080;         // virtual design height

// Day/Night control
let dayNightT = 0;             // 0 = day, 1 = night
let targetDayNightT = 0;       // for smooth transitions
let dayNightLerpSpeed = 0.04;  // transition speed

// Frame & animation settings
const FRAME_X = 656;
const FRAME_Y = 152;
const FRAME_W = 600;
const FRAME_H = 600;

// Big blocks used as “lights”
let bigBlocks = [];

// Flowing color patches
let yellowRoadCells = [];   // Record yellow road grids
let flowParticles = [];     // Flowing particles generated by yellow grids
let flowActive = false;     // Toggle with 'M' to start/stop night traffic flow

// Generate “flowable rectangles” using all road tiles
let flowingBlocks = [];     // Save the road rectangles in all colors

let glitchActive = false;   // Nighttime S activated deconstruction glitch

// Moonlight direction
let moonLightX = 0;
let moonLightY = 0;

// Save zoom scale (from source image to artCanvas)
let scaleXToArt = 1;
let scaleYToArt = 1;

// Flickering light control
let activeFlash = false;
let flashBaseSpeed = 0.25;

// Sampling parameters to control the size and ignore the imperfection of the map image
const SAMPLE_STEP = 25;
const UNIT_SIZE = 30;

// Shadow movement
const SHADOW_MAX_OFFSET = 10;
const SHADOW_SMOOTHING = 0.06;
let currentShadowOffsetX = 0;
let currentShadowOffsetY = 0;

// Photo flash state
let photoFlashT = 0.8;      // Flash intensity
let shotShake = 0.3;        // Image shake intensity
let nightShakeActive = false;  

// Data classes

// Store blocks that act as “lights” at night.
class BigBlock {
  constructor(x, y, w, h, color) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.color = color;
  }
}

// Store flowing blocks used for nighttime traffic animation.
class FlowBlock {
  constructor(x, y, w, h, color, direction, offset, speed) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.color = color;
    this.direction = direction;
    this.offset = offset;
    this.speed = speed;
  }
}

function preload() {
  sourceImage = loadImage('Street.png'); 
  // load image https://p5js.org/reference/p5/preload/
}

function setup() {
  // canvas size follows the window; we draw into a fixed 1920x1080 design space
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);

  // content outside the element box is not shown
  document.body.style.overflow = 'hidden';  // https://www.w3schools.com/jsref/prop_style_overflow.asp

  // Create graphics buffer for art generation
  artCanvas = createGraphics(600, 600);
  artCanvas.pixelDensity(1);  // https://p5js.org/reference/p5/pixelDensity/

  generateArt();
  ready = true;
}

function draw() {
  background(255);

  // Camera shake in design space
  let shakeX = 0;
  let shakeY = 0;
  if (shotShake > 0) {
    let amp = shotShake * 20;         // Jitter magnitude (pixels in design space)
    shakeX = random(-amp, amp);
    shakeY = random(-amp, amp);
    shotShake *= 0.85;                // Gradually diminish
    if (shotShake < 0.01) shotShake = 0;
  }

  // Responsive scaling into 1920x1080 design space (group logic)
  const s = Math.max(width / DESIGN_W, height / DESIGN_H);
  const offsetX = (width  - DESIGN_W * s) / 2;
  const offsetY = (height - DESIGN_H * s) / 2;

  push();
  // move and scale the whole 1920x1080 "virtual wall" into the real window
  translate(offsetX, offsetY);
  scale(s);

  // apply camera shake inside the design space
  translate(shakeX, shakeY);

  // Camera zoom inside the design space (same zoom as group code)
  let zoom = 1.25;
  let zoomAnchorY = DESIGN_H * 0.75;

  push();
  translate(DESIGN_W / 2, zoomAnchorY / 2);
  scale(zoom);
  translate(-DESIGN_W / 2, -zoomAnchorY / 2);

  // Shadow parallax & gallery background (still using real mouseX/Y)
  let targetOffsetX = map(mouseX, 0, width,  -SHADOW_MAX_OFFSET, SHADOW_MAX_OFFSET);
  let targetOffsetY = map(mouseY, 0, height, -SHADOW_MAX_OFFSET, SHADOW_MAX_OFFSET);

  currentShadowOffsetX = lerp(currentShadowOffsetX, targetOffsetX, SHADOW_SMOOTHING);
  currentShadowOffsetY = lerp(currentShadowOffsetY, targetOffsetY, SHADOW_SMOOTHING);

  drawBackground(currentShadowOffsetX, currentShadowOffsetY);

  // Update moonlight direction (night only) 
  if (dayNightT > 0.4) {
    moonLightX = mouseX;
    moonLightY = mouseY;
  }

  // Artwork inside the frame
  if (ready) {
    // Default: no shake
    let jitterX = 0;
    let jitterY = 0;

    // Only when it's nighttime and glitchActive is enabled will it flicker
    if (glitchActive && dayNightT > 0.4) {
      let jitterAmp = 8;
      jitterX = random(-jitterAmp, jitterAmp);
      jitterY = random(-jitterAmp, jitterAmp);
    }

    // Paint artwork within the frame, adding jitter offset
    push();
    translate(jitterX, jitterY);
    image(artCanvas, FRAME_X, FRAME_Y, FRAME_W, FRAME_H);
    drawFlowingBlocks();
    drawBlockLights();
    pop();

    // Nighttime glitch within the frame
    if (glitchActive && dayNightT > 0.4) {
      let pieces = 40;  // The bigger, the more exaggerated

      // Screen scaling ratio from artCanvas to frame
      let sxRatio = FRAME_W / artCanvas.width;
      let syRatio = FRAME_H / artCanvas.height;

      for (let i = 0; i < pieces; i++) {
        // Randomly select a small section within the artCanvas
        let sw = random(30, 100);                  // Source width
        let sh = random(15, 60);                   // Source height
        let sx = random(0, artCanvas.width  - sw); // Source x
        let sy = random(0, artCanvas.height - sh); // Source y

        // Normal position of this block within the frame
        let baseDx = FRAME_X + sx * sxRatio;
        let baseDy = FRAME_Y + sy * syRatio;
        let dw = sw * sxRatio;
        let dh = sh * syRatio;

        // Small offset nearby
        let offsetX = random(-15, 15);
        let offsetY = random(-15, 15);

        // Create a jumbled effect
        image(
          artCanvas,
          baseDx + offsetX, baseDy + offsetY, dw, dh,  // Target position + size
          sx, sy, sw, sh                               // Source position + size
        );
      }
    }
  }

  pop();  // end zoom
  pop();  // end responsive scaling

  // Day/Night overlay & extra effects
  applyDayNightFilter();  
  drawMoonLight();        
  drawPhotoFlash();       
}

// Click to regenerate artwork
function mousePressed() {
  generateArt();
}

// Click to activate nighttime flashing lights
function mouseClicked() {
  if (mouseButton === LEFT) {
    // Left button: control flashlight
    if (dayNightT < 0.4) return;
    activeFlash = !activeFlash;
  }
}

// Base colors like Mondrian
let colors = {
  gray:   '#d6d7d2',
  yellow: '#e1c927',
  red:    '#ad372b',
  blue:   '#314294',
  bg:     '#EBEAE6'
};

function generateArt() {
  yellowRoadCells = [];  // Clear the road cells before each generation
  flowingBlocks  = [];   // Clear the “flowable rectangles” each time redraw
  
  // Setup artCanvas
  artCanvas.push();
  artCanvas.clear();  // https://p5js.org/reference/p5/clear/
  artCanvas.background(colors.bg);
  artCanvas.noStroke();

  // First draw the large square layer
  drawSVGBlocks();

  // Then draw the road sampling layer.
  sourceImage.loadPixels();  // https://p5js.org/reference/p5/loadPixels/
  
  // Scale & block size
  const scaleX = artCanvas.width  / sourceImage.width;
  const scaleY = artCanvas.height / sourceImage.height;

  // Store to global variables
  scaleXToArt = scaleX;
  scaleYToArt = scaleY;

  const blockSize = UNIT_SIZE * Math.min(scaleX, scaleY);
  
  // Create grid for storing colors
  const rows = Math.ceil(sourceImage.height / SAMPLE_STEP);
  const cols = Math.ceil(sourceImage.width  / SAMPLE_STEP);
  const grid = Array(rows).fill().map(function() {
    return Array(cols).fill(null);
  });
  
  // Sample pixels and record colors
  for (let y = 0, row = 0; y < sourceImage.height; y += SAMPLE_STEP, row++) {
    for (let x = 0, col = 0; x < sourceImage.width; x += SAMPLE_STEP, col++) {
      const idx = (y * sourceImage.width + x) * 4;
      const r = sourceImage.pixels[idx];
      const g = sourceImage.pixels[idx + 1];
      const b = sourceImage.pixels[idx + 2];
      
      // Road pixel (white)
      if (r > 240 && g > 240 && b > 240) {
        grid[row][col] = chooseColor(grid, row, col);

        // Mark yellow squares as “roads” for potential flow
        if (grid[row][col] === colors.yellow) {
          yellowRoadCells.push({
            row,
            col,
            color: grid[row][col]
          });
        }
      }
    }
  }

  // Draw rectangles from grid
  for (let y = 0, row = 0; y < sourceImage.height; y += SAMPLE_STEP, row++) {
    for (let x = 0, col = 0; x < sourceImage.width; x += SAMPLE_STEP, col++) {
      if (grid[row][col]) {
        const bx = x * scaleX;
        const by = y * scaleY;
        const bw = blockSize;
        const bh = blockSize;
        const colr = grid[row][col];
        // ampScale = 1.2 for smaller blocks
        feltifyRect(artCanvas, bx, by, bw, bh, colr, 1.2);

        // Determine whether this cell is a vertical road or a horizontal road
        let isVertical   = false;
        let isHorizontal = false;

        if (row > 0           && grid[row - 1][col] !== null) isVertical   = true;
        if (row < rows - 1    && grid[row + 1][col] !== null) isVertical   = true;
        if (col > 0           && grid[row][col - 1] !== null) isHorizontal = true;
        if (col < cols - 1    && grid[row][col + 1] !== null) isHorizontal = true;

        let direction = "vertical";
        if (isHorizontal && !isVertical) {
          direction = "horizontal";
        }

        // Record a set of “moving road blocks” for the nighttime overlay layer
        flowingBlocks.push(
          new FlowBlock(
            bx,
            by,
            bw,
            bh,
            colr,
            direction,
            random(0, bw * 2),     // offset
            random(0, 0.5) + 1.0   // speed 
          )
        );
      }
    }
  }

  artCanvas.pop();
}

// Mondrian-style big blocks
function drawSVGBlocks() {
  const g = artCanvas;
  g.noStroke();

  const s = 1600 / 600;  // Canvas scale

  // clear old big blocks.
  bigBlocks = [];

  // helper: create a big block and store it
  function R(x, y, w, h, c) {
    // Convert to artCanvas coordinates
    let rx = Math.round(x / s);
    let ry = Math.round(y / s);
    let rw = Math.round(w / s);
    let rh = Math.round(h / s);

    // Draw clean rectangles without jagged edges.
    g.noStroke();
    g.fill(c);
    g.rect(rx, ry, rw, rh);

    // Record to the array as BigBlock instance
    bigBlocks.push(new BigBlock(rx, ry, rw, rh, c));
  }

  R(910, 305, 275, 420, '#4267ba');
  R(910, 390, 275, 230, '#ad372b');
  R(960, 450, 160, 100, '#e1c927');
  R(80, 1160, 160, 140, '#e1c927');
  R(230, 960, 150, 130, "#4267ba");
  R(1450, 1450, 165, 165, '#e1c927');
  R(730, 280, 95, 95, '#e1c927'); 
  R(385, 1300, 195, 310, '#ad372b');
  R(450, 1360, 60, 60, '#d6d7d2');
  R(1005, 1060, 175, 390, "#4267ba");
  R(1025, 1295, 125, 100, '#e1c927');
  R(150, 455, 225, 120, "#4267ba");
  R(280, 160, 205, 85, '#ad372b');
  R(1380, 70, 180, 120, "#4267ba");
  R(1400, 625, 210, 210, "#ad372b");
  R(1270, 865, 130, 190, '#e1c927');
  R(610, 945, 215, 215, '#e1c927');
  R(385, 740, 220, 90, '#ad372b');
  R(830, 730, 155, 155, '#ad372b');
  R(1470, 700, 80, 60, '#d6d7d2');
  R(280, 1000, 50, 50, '#d6d7d2');
  R(670, 1020, 80, 80, '#d6d7d2');
  R(340, 160, 40, 85, '#d6d7d2');
  R(1295, 915, 75, 75, '#d6d7d2');
  R(750, 305, 45, 45, '#d6d7d2');   
}

// choose color with probability and neighbor checking
function chooseColor(grid, row, col) {
  const avoid = [];
  
  // top 
  if (row > 0 && grid[row - 1][col] && grid[row - 1][col] !== colors.yellow) {
    avoid.push(grid[row - 1][col]);
  }
  
  // left   
  if (col > 0 && grid[row][col - 1] && grid[row][col - 1] !== colors.yellow) {
    avoid.push(grid[row][col - 1]);
  }
  
  const weights = [
    { color: colors.gray,   weight: 10 },
    { color: colors.yellow, weight: 60 },
    { color: colors.red,    weight: 10 },
    { color: colors.blue,   weight: 20 }
  ];
  
  const available = weights.filter(function(w) {
    return !avoid.includes(w.color);
  });
  
  if (available.length === 0) return colors.yellow;
  
  const total = available.reduce(function(sum, w) {
    return sum + w.weight;
  }, 0);

  let rand = random(total);
  
  for (let i = 0; i < available.length; i++) {
    if (rand < available[i].weight) {
      return available[i].color;
    }
    rand -= available[i].weight;
  }
  
  return available[0].color;
}

// Background space drawing
function drawBackground(shadowOffsetX = 0, shadowOffsetY = 0) {
  noStroke();

  // Wall
  fill('#F5F4F0');
  rect(0, 2, DESIGN_W, 910);

  // Floor line
  fill('#6C4D38');
  rect(0, 868, DESIGN_W, 8);

  // Floor strips
  fill('#A88974');
  rect(0, 875, DESIGN_W, 8);
  fill('#DBBDA5');
  rect(0, 883, DESIGN_W, 12);
  fill('#CEB1A1');
  rect(0, 895, DESIGN_W, 20);
  fill('#DDC3AC');
  rect(0, 915, DESIGN_W, 30);
  fill('#DDBFA7');
  rect(0, 945, DESIGN_W, 40);
  fill('#E4C9B4');
  rect(0, 985, DESIGN_W, 50);

  // layered rectangles to create a shadow effect
  fill('#A88974'); // Deepest shadow (moves with mouse)
  rect(630 + shadowOffsetX * 0.6, 132 + shadowOffsetY * 0.6, 670, 677);
 
  fill('#E1E0DC'); // Light edge of the frame
  rect(620, 120, 666, 664); 

  fill('#BFA89A'); // Frame border (moves slightly)
  rect(658 + shadowOffsetX * 0.2, 153 + shadowOffsetY * 0.1, 606, 622); 

  fill('#A88974'); // Shadow at the bottom of the frame
  rect(658 + shadowOffsetX * 0.1, 153 + shadowOffsetY * 0.1, 604, 612);
}

// Hand-drawn styles in visual
function feltifyRect(g, x, y, w, h, c, ampScale = 1) {
  // main color block
  g.noStroke();
  g.fill(c);
  g.rect(x, y, w, h);

  // Slight shaking outline
  const amp   = 0.36 * ampScale;     
  const freq  = 0.1;   
  const layers = 6;     

  for (let l = 0; l < layers; l++) {
    g.noFill();
    g.stroke(red(c), green(c), blue(c), map(l, 0, layers - 1, 100, 50));
    g.strokeWeight(map(l, 0, layers - 1, 2.2, 1));

    g.beginShape();

    // up
    for (let i = 0; i <= 1; i += 0.02) {
      const n = noise((x + i * w) * freq, (y + l * 50) * freq);
      const offset = map(n, 0, 1, -amp, amp);
      g.vertex(x + i * w, constrain(y + offset, y - amp, y + amp));
    }

    // Right
    for (let i = 0; i <= 1; i += 0.02) {
      const n = noise((x + w + l * 20) * freq, (y + i * h) * freq);
      const offset = map(n, 0, 1, -amp, amp);
      g.vertex(constrain(x + w + offset, x + w - amp, x + w + amp), y + i * h);
    }

    // down
    for (let i = 1; i >= 0; i -= 0.02) {
      const n = noise((x + i * w) * freq, (y + h + l * 40) * freq);
      const offset = map(n, 0, 1, -amp, amp);
      g.vertex(x + i * w, constrain(y + h + offset, y + h - amp, y + h + amp));
    }

    // Left
    for (let i = 1; i >= 0; i -= 0.02) {
      const n = noise((x + l * 30) * freq, (y + i * h) * freq);
      const offset = map(n, 0, 1, -amp, amp);
      g.vertex(constrain(x + offset, x - amp, x + amp), y + i * h);
    }

    g.endShape(CLOSE);     // https://p5js.org/reference/p5/endShape/
  }

  // Soft glow outline
  g.stroke(red(c), green(c), blue(c), 40);
  g.strokeWeight(3);
  g.noFill();
  g.rect(x, y, w, h);
}

// Nighttime block lights
function drawBlockLights() {
  if (!activeFlash) return;
  if (dayNightT < 0.4) return; 

  noStroke();

  for (let i = 0; i < bigBlocks.length; i++) {
    let b = bigBlocks[i];
    let col = color(b.color);

    // Let each block beat slightly differently
    let t = frameCount * flashBaseSpeed + i * 0.8;
    let brightness = (sin(t) + 1) * 0.5; // 0~1
    let alpha = lerp(40, 200, brightness);

    fill(red(col), green(col), blue(col), alpha);

    // Map the artCanvas coordinates to the main canvas (artwork frame)
    let rx = FRAME_X + b.x * (FRAME_W / artCanvas.width);
    let ry = FRAME_Y + b.y * (FRAME_H / artCanvas.height);
    let rw = b.w * (FRAME_W / artCanvas.width);
    let rh = b.h * (FRAME_H / artCanvas.height);
    rect(rx, ry, rw, rh);
  }
}

// Flowing road blocks (night traffic)
function drawFlowingBlocks() {
  if (!flowActive || dayNightT < 0.4) return;

  let artToScreenX = FRAME_W / artCanvas.width;
  let artToScreenY = FRAME_H / artCanvas.height;

  const LOOP_FACTOR  = 2.6;   // Control cycle distance
  const GLOBAL_SPEED = 0.25;

  for (let b of flowingBlocks) {
    // Update offset per frame (plus global speed coefficient)
    b.offset += b.speed * GLOBAL_SPEED;

    // After one cycle, loop (without exiting the frame)
    let loopRange = (b.direction === "vertical" ? b.h : b.w) * LOOP_FACTOR;
    if (b.offset > loopRange) b.offset = 0;

    let sx, sy;
    let sw = b.w * artToScreenX;
    let sh = b.h * artToScreenY;

    if (b.direction === "vertical") {
      let shift = b.offset % (b.h * 1.0);
      let canvasY = b.y + shift;

      canvasY = constrain(canvasY, 0, artCanvas.height - b.h);

      sx = FRAME_X + b.x * artToScreenX;
      sy = FRAME_Y + canvasY * artToScreenY;
    } else {
      let shift = b.offset % (b.w * 1.0);
      let canvasX = b.x + shift;

      canvasX = constrain(canvasX, 0, artCanvas.width - b.w);
      sx = FRAME_X + canvasX * artToScreenX;
      sy = FRAME_Y + b.y * artToScreenY;
    }

    noStroke();
    fill(b.color);
    rect(sx, sy, sw, sh);
  }
}

function windowResized() {
  // keep canvas matched to window; scaling into DESIGN_W/H is handled in draw()
  resizeCanvas(windowWidth, windowHeight);
}

// Day/Night overlay effect
function applyDayNightFilter() {
  // Smoothly interpolate to target value
  dayNightT = lerp(dayNightT, targetDayNightT, dayNightLerpSpeed);

  // Transparency (darkness level)
  let darkness = map(dayNightT, 0, 1, 0, 0.65); // https://p5js.org/reference/p5/map/

  // Night blue tint
  let blueTint = map(dayNightT, 0, 1, 0, 80);
  noStroke();
  fill(0, 50, blueTint, darkness * 255);
  rect(0, 0, width, height);
}

function drawPhotoFlash() {
  // Only effective in day mode
  if (dayNightT > 0.3) return;
  if (photoFlashT <= 0) return;

  // The larger the alpha value, the brighter the image.  
  let alpha = photoFlashT * 255;
  noStroke();
  fill(255, 255, 255, alpha);
  rect(0, 0, width, height);

  // Gradually fade out
  photoFlashT -= 0.08;
  if (photoFlashT < 0) photoFlashT = 0;
}

function keyPressed() {
  if (key === 'd' || key === 'D') {
    targetDayNightT = 0; // Day
  }
  if (key === 'n' || key === 'N') {
    targetDayNightT = 1; // Night
  }
  if (key === 'm' || key === 'M') {  // M: controls the flow of small yellow road blocks
    flowActive = !flowActive;
  }

  // P: Flash for photos, only activates during daylight
  if (key === 'p' || key === 'P') {
    if (dayNightT < 0.3) {
      photoFlashT = 1.0;
      shotShake   = 1.0;
    }
  }

  // S: deconstruction of the work
  if (key === 's' || key === 'S') {
    if (dayNightT > 0.4) {
      glitchActive = !glitchActive;
    }
  }
}

function drawMoonLight() {
  if (dayNightT < 0.4) return;

  // Use the same scale factor as the virtual 1920x1080 wall
  const scaleFactor = Math.max(width / DESIGN_W, height / DESIGN_H);

  // 600 was the original max radius on a 1920px-wide canvas
  let maxR = 600 * scaleFactor;
  let step = 20 * scaleFactor; // keep a similar number of rings

  push();
  for (let r = maxR; r > 0; r -= step) {
    let alpha = map(r, 0, maxR, 180, 0);
    fill(255, 255, 220, alpha * 0.25);
    noStroke();
    ellipse(moonLightX, moonLightY, r, r * 0.8);
  }
  pop();
}