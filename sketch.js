let sourceImage;
// Day/Night control
const baseWidth = 1920;
const baseHeight = 1080;
let dayNightT = 0;             // 0 = day, 1 = night
let targetDayNightT = 0;       // for smooth transitions
let dayNightLerpSpeed = 0.04;  // transition speed
let artCanvas;                 // define artCanvas
let ready = false;             // track if art is ready
//Frame & animation settings
const FRAME_X = 656;
const FRAME_Y = 152;
const FRAME_W = 600;
const FRAME_H = 600;

// Big blocks used as “lights”
let bigBlocks = [];
// Flowing color patches
let yellowRoadCells = [];   // Record yellow road grids
let flowParticles = [];     // Flowing particles generated by yellow grids
let flowActive = false;     // Right-click to toggle to check if its flowing
// Generate “flowable rectangles” using all road tiles
let flowingBlocks = [];     // Save the road rectangles in all colors
let glitchActive = false;   // Nighttime S-key activated deconstruction glitch
// Moonlight/Spotlight Direction
let moonLightX = 0;
let moonLightY = 0;
// Save Zoom Scale
let scaleXToArt = 1;
let scaleYToArt = 1;
// Flickering Light Control
let activeFlash = false;
let flashBaseSpeed = 0.25;

//  sampling parameters to control the size and ignore the imperfection of the map image
const SAMPLE_STEP = 25;
const UNIT_SIZE = 30;

// shadow movement
const SHADOW_MAX_OFFSET = 10; 
const SHADOW_SMOOTHING = 0.06; 
let currentShadowOffsetX = 0; 
let currentShadowOffsetY = 0; 
let photoFlashT = 0.8;      // Flash Intensity
let shotShake = 0.3;        // Image Shake Intensity）
let nightShakeActive = false;  

function clamp(v, minV, maxV) {
  return Math.max(minV, Math.min(maxV, v));
}
function preload() {
  sourceImage = loadImage('Street.png'); 
  // load image https://p5js.org/reference/p5/preload/
}
function setup() {
  createCanvas(baseWidth, baseHeight); // create main canvas
  pixelDensity(1);
  // Content outside the element box is not shown https://www.w3schools.com/jsref/prop_style_overflow.asp
  document.body.style.overflow = 'hidden';
  // create graphics buffer for art generation
  artCanvas = createGraphics(600, 600);
  artCanvas.pixelDensity(1); // https://p5js.org/reference/p5/loadPixels/ // Get the pixel density.
  
  generateArt();
  ready = true;
  scaleToWindow();                   // scale to window size
}
function draw() {
  // Background color
  background(255);

  // Calculate camera shake offset
  let shakeX = 0;
  let shakeY = 0;
  if (shotShake > 0) {
    let amp = shotShake * 20;         // Jitter Magnitude (pixels)
    shakeX = random(-amp, amp);
    shakeY = random(-amp, amp);
    shotShake *= 0.85;                // gradually diminish
    if (shotShake < 0.01) shotShake = 0;
  }

  // Full-screen zoom + added jitter
  let zoom = 1.25;
  let zoomAnchorY = height * 0.75;
    push(); 
  // First apply jitter
  translate(shakeX, shakeY);
  // Apply the original scale & position
  translate(width / 2, zoomAnchorY / 2); 
  scale(zoom); 
  translate(-width / 2, -zoomAnchorY / 2); 

  // Mouse-controlled frame shadow offset
  let targetOffsetX = map(mouseX, 0, width, -SHADOW_MAX_OFFSET, SHADOW_MAX_OFFSET); 
  let targetOffsetY = map(mouseY, 0, height, -SHADOW_MAX_OFFSET, SHADOW_MAX_OFFSET);
  currentShadowOffsetX = lerp(currentShadowOffsetX, targetOffsetX, SHADOW_SMOOTHING);
  currentShadowOffsetY = lerp(currentShadowOffsetY, targetOffsetY, SHADOW_SMOOTHING);

  // Drawing backgrounds and frames
  drawBackground(currentShadowOffsetX, currentShadowOffsetY); 

  // Update Moonlight Direction
  if (dayNightT > 0.4) {
  
 // Mouse position mapped to a local area within the drawing frame region
  moonLightX = mouseX;
  moonLightY = mouseY;
}

 // The Artwork Itself
 if (ready) {

// Default: No shake
  let jitterX = 0;
  let jitterY = 0;

  // Only when it's nighttime and glitchActive is enabled will it flicker
  if (glitchActive && dayNightT > 0.4) {
  let jitterAmp = 8;           
    jitterX = random(-jitterAmp, jitterAmp);
    jitterY = random(-jitterAmp, jitterAmp);
}

  // Paint “artwork within the entire frame,” adding jitter offset
  push();
  translate(jitterX, jitterY);
  image(artCanvas, FRAME_X, FRAME_Y, FRAME_W, FRAME_H);
  drawFlowingBlocks();
  drawBlockLights();
  pop();
    
  // When glitchActive is enabled at night, perform glitch slicing within the frame.
  if (glitchActive && dayNightT > 0.4) {
  let pieces = 40;                                  // The bigger, the more exaggerated

    // Screen scaling ratio
  let sxRatio = FRAME_W / artCanvas.width;
  let syRatio = FRAME_H / artCanvas.height;
    for (let i = 0; i < pieces; i++) {

   // Randomly select a small section within the artCanvas
  let sw = random(30, 100);                    // Source width
  let sh = random(15, 60);                     // Source height
  let sx = random(0, artCanvas.width - sw);    // Source x
  let sy = random(0, artCanvas.height - sh);   // Source y

  // Calculate the normal position of this block within the frame
  let baseDx = FRAME_X + sx * sxRatio;
  let baseDy = FRAME_Y + sy * syRatio;
  let dw = sw * sxRatio;
  let dh = sh * syRatio;

  // Make a little offsetting nearby
  let offsetX = random(-15, 15);
  let offsetY = random(-15, 15);

  // Create a jumbled effect
  image(
    artCanvas,
    baseDx + offsetX, baseDy + offsetY, dw, dh,  // Target Position + Size
    sx, sy, sw, sh                               // Source position + size
      );
    }
  }
}

  // Day/Night Filter
  applyDayNightFilter();

  // Nighttime Moonlight Effect (Mouseover)
  drawMoonLight();

  // Photo Flash Overlay
  drawPhotoFlash();
}

  // Click to regenerate artwork
  function mousePressed() {
  generateArt();
}

  // Click to activate nighttime flashing lights
  function mouseClicked() {
  if (mouseButton === LEFT) {
  
  // Left button: Control flashlight
  if (dayNightT < 0.4) return;
  activeFlash = !activeFlash;
  }
}

// Base color like mondrian
let colors = {
  gray: '#d6d7d2',
  yellow: '#e1c927',
  red: '#ad372b',
  blue: '#314294',
  bg: '#EBEAE6'
};

function generateArt() {
  yellowRoadCells = [];  // Clear the road before each generation
  flowingBlocks = [];    // Clear the “flowable rectangles” each time redraw
  
  // setup artCanvas 
  artCanvas.push();
  artCanvas.clear();
  artCanvas.background(colors.bg);
  artCanvas.noStroke();

  // First draw the large square layer
  drawSVGBlocks();

  // Then draw the road sampling layer.

  // https://p5js.org/reference/p5/loadPixels/
  sourceImage.loadPixels();
  
  // Scale & blocksize
  const scaleX = artCanvas.width / sourceImage.width;
  const scaleY = artCanvas.height / sourceImage.height;

  // Store to a global variable
  scaleXToArt = scaleX;
  scaleYToArt = scaleY;

  const blockSize = UNIT_SIZE * Math.min(scaleX, scaleY);
  
  // create grid for storing colors
  const rows = Math.ceil(sourceImage.height / SAMPLE_STEP);
  const cols = Math.ceil(sourceImage.width / SAMPLE_STEP);
  const grid = Array(rows).fill().map(function() {
    return Array(cols).fill(null);
  });
  
  // sample pixels and draw colored squares
  for (let y = 0, row = 0; y < sourceImage.height; y += SAMPLE_STEP, row++) {
  for (let x = 0, col = 0; x < sourceImage.width; x += SAMPLE_STEP, col++) {
 
  // Get pixel color
  const idx = (y * sourceImage.width + x) * 4;
  const r = sourceImage.pixels[idx];
  const g = sourceImage.pixels[idx + 1];
  const b = sourceImage.pixels[idx + 2];
      
  // Check if it's a road pixel (white color)
  if (r > 240 && g > 240 && b > 240) {
  grid[row][col] = chooseColor(grid, row, col);

  // Mark the yellow squares as “roads” and record the colors  
  if (grid[row][col] === colors.yellow) {
    yellowRoadCells.push({
      row,
      col,
      color: grid[row][col]
    });
  }
}
    }
  }
  // draw rectangles from grid
  for (let y = 0, row = 0; y < sourceImage.height; y += SAMPLE_STEP, row++) {
    for (let x = 0, col = 0; x < sourceImage.width; x += SAMPLE_STEP, col++) {
      if (grid[row][col]) {
        const bx = x * scaleX;
        const by = y * scaleY;
        const bw = blockSize;
        const bh = blockSize;
        const colr = grid[row][col];

        // Maintain your original texture）
        feltifyRect(artCanvas, bx, by, bw, bh, colr, 1.2);

        // Determine whether this cell is a vertical road or a horizontal road
        let isVertical = false;
        let isHorizontal = false;

        if (row > 0 && grid[row - 1][col] !== null) isVertical = true;
        if (row < rows - 1 && grid[row + 1][col] !== null) isVertical = true;

        if (col > 0 && grid[row][col - 1] !== null) isHorizontal = true;
        if (col < cols - 1 && grid[row][col + 1] !== null) isHorizontal = true;

        let direction = "vertical";
        if (isHorizontal && !isVertical) {
          direction = "horizontal";
        }

        // Record a set of “mobile cart block” data for nighttime overlay layers
        flowingBlocks.push({
        x: bx,
        y: by,
        w: bw,
        h: bh,
        color: colr,
        direction: direction,
        offset: random(0, bw * 2),
        speed: random(0.5, 1.5),

  // Join the boundary of the lane where the current cell is located
  minX: bx,
  maxX: bx + bw,
  minY: by,
  maxY: by + bh
    });
   }
  }
 }
  artCanvas.pop();
}

  // Mondrian-style big blocks
  function drawSVGBlocks() {
  const g = artCanvas;
  g.noStroke();

  const s = 1600 / 600;  //cal canvas scale

  // Clear the canvas before each new drawing.
  bigBlocks = [];

  function R(x, y, w, h, c) {
    // First convert to artCanvas coordinates
    let rx = Math.round(x / s);
    let ry = Math.round(y / s);
    let rw = Math.round(w / s);
    let rh = Math.round(h / s);

    // Draw clean rectangles without jagged edges.
    g.noStroke();
    g.fill(c);
    g.rect(rx, ry, rw, rh);

    // Record to the array
    bigBlocks.push({
      x: rx,
      y: ry,
      w: rw,
      h: rh,
      color: c
  });
 }

     R(910, 305, 275, 420, '#4267ba');
     R(910, 390, 275, 230, '#ad372b');
     R(960, 450, 160, 100, '#e1c927');
     R(80, 1160, 160, 140, '#e1c927');
     R(230, 960, 150, 130, "#4267ba");
     R(1450, 1450, 165, 165, '#e1c927');
     R(730, 280, 95, 95, '#e1c927'); 
     R(385, 1300, 195, 310, '#ad372b');
     R(450, 1360, 60, 60, '#d6d7d2');
     R(1005, 1060, 175, 390, "#4267ba");
     R(1025, 1295, 125, 100, '#e1c927');
     R(150, 455, 225, 120, "#4267ba");
     R(280, 160, 205, 85, '#ad372b');
     R(1380, 70, 180, 120, "#4267ba");
     R(1400, 625, 210, 210, '#ad372b');
     R(1270, 865, 130, 190, '#e1c927');
     R(610, 945, 215, 215, '#e1c927');
     R(385, 740, 220, 90, '#ad372b');
     R(830, 730, 155, 155, '#ad372b');
     R(1470, 700, 80, 60, '#d6d7d2');
     R(280, 1000, 50, 50, '#d6d7d2');
     R(670, 1020, 80, 80, '#d6d7d2');
     R(340, 160, 40, 85, '#d6d7d2');
     R(1295, 915, 75, 75, '#d6d7d2');
     R(750, 305, 45, 45, '#d6d7d2');   
}

  // choose color with probability and neighbor checking （like in mondian’s work）
  function chooseColor(grid, row, col) {
  const avoid = [];
  
  // Check top neighbor（&& is like and in python）
  if (row > 0 && grid[row - 1][col] && grid[row - 1][col] !== colors.yellow) {
    avoid.push(grid[row - 1][col]);
  }
  
  // Check left neighbor  
  if (col > 0 && grid[row][col - 1] && grid[row][col - 1] !== colors.yellow) {
    avoid.push(grid[row][col - 1]);
  }
  
  // color weights
  const weights = [
    { color: colors.gray, weight: 10 },
    { color: colors.yellow, weight: 60 },
    { color: colors.red, weight: 10 },
    { color: colors.blue, weight: 20 }
  ];
  
  // filter out avoided colors
  const available = weights.filter(function(w) {
    return !avoid.includes(w.color);
  });
  
  // default to yellow if no colors available（since the original work has lots of yellow）
  if (available.length === 0) return colors.yellow;
  
  // calculate total weight
  const total = available.reduce(function(sum, w) {
    return sum + w.weight;
  }, 0);
  
  // weighted random selection
  let rand = random(total);
  
  for (let i = 0; i < available.length; i++) {
    if (rand < available[i].weight) {
    return available[i].color;
    }
    rand -= available[i].weight;
  }
  
  return available[0].color;
}

// Background space drawing function
 function drawBackground(shadowOffsetX = 0, shadowOffsetY = 0) {
 noStroke();

 // wall
 fill('#F5F4F0');
 rect(0, 2, 1920, 910);

 // floor line
 fill('#6C4D38');
 rect(0, 868, 1920, 8);

 // floor strips
 fill('#A88974');
 rect(0, 875, 1920, 8);
 fill('#DBBDA5');
 rect(0, 883, 1920, 12);
 fill('#CEB1A1');
 rect(0, 895, 1920, 20);
 fill('#DDC3AC');
 rect(0, 915, 1920, 30);
 fill('#DDBFA7');
 rect(0, 945, 1920, 40);
 fill('#E4C9B4');
 rect(0, 985, 1920, 50);

 // layered rectangles to create a shadow effect
 
 fill('#A88974'); // deepest shadow (move)
 rect(630 + shadowOffsetX * 0.6, 132 + shadowOffsetY * 0.6, 670, 677);
 
 fill('#E1E0DC'); // light edge of the frame
 rect(620, 120, 666, 664); 

 fill('#BFA89A'); // frame border (move)
 rect(658 + shadowOffsetX * 0.2, 153 + shadowOffsetY * 0.1, 606, 622); 

 fill('#A88974'); // shadow at the bottom of the frame (move)
 rect(658 + shadowOffsetX * 0.1, 153 + shadowOffsetY * 0.1, 604, 612);
}
  // Hand-drawn style in visuals
function feltifyRect(g, x, y, w, h, c, ampScale = 1) {
  
  // Draw the main color block
  g.noStroke();
  g.fill(c);
  g.rect(x, y, w, h);

  // slight shaking
  const amp = 0.36 * ampScale;     
  const freq = 0.1;   
  const layers = 6;     

  for (let l = 0; l < layers; l++) {
    g.noFill();
    g.stroke(red(c), green(c), blue(c), map(l, 0, layers - 1, 100, 50));
    g.strokeWeight(map(l, 0, layers - 1, 2.2, 1));

    g.beginShape();

    // up
    for (let i = 0; i <= 1; i += 0.02) {
      const n = noise((x + i * w) * freq, (y + l * 50) * freq);
      const offset = map(n, 0, 1, -amp, amp);
      g.vertex(x + i * w, constrain(y + offset, y - amp, y + amp));
    }

    // right
    for (let i = 0; i <= 1; i += 0.02) {
      const n = noise((x + w + l * 20) * freq, (y + i * h) * freq);
      const offset = map(n, 0, 1, -amp, amp);
      g.vertex(constrain(x + w + offset, x + w - amp, x + w + amp), y + i * h);
    }

    // down
    for (let i = 1; i >= 0; i -= 0.02) {
      const n = noise((x + i * w) * freq, (y + h + l * 40) * freq);
      const offset = map(n, 0, 1, -amp, amp);
      g.vertex(x + i * w, constrain(y + h + offset, y + h - amp, y + h + amp));
    }

    // left
    for (let i = 1; i >= 0; i -= 0.02) {
      const n = noise((x + l * 30) * freq, (y + i * h) * freq);
      const offset = map(n, 0, 1, -amp, amp);
      g.vertex(constrain(x + offset, x - amp, x + amp), y + i * h);
    }

    g.endShape(CLOSE);
  }

  // soft glow outline
  g.stroke(red(c), green(c), blue(c), 40);
  g.strokeWeight(3);
  g.noFill();
  g.rect(x, y, w, h);
}

  // Flashing lights at night
 function drawBlockLights() {
  if (!activeFlash) return;
  if (dayNightT < 0.4) return; 

  noStroke();

  for (let i = 0; i < bigBlocks.length; i++) {
    let b = bigBlocks[i];
    let col = color(b.color);

  // Let each beat be slightly different
    let t = frameCount * flashBaseSpeed + i * 0.8;
    let brightness = (sin(t) + 1) * 0.5; // 0~1
    let alpha = lerp(40, 200, brightness);

    fill(red(col), green(col), blue(col), alpha);

  // Map the artCanvas coordinates to the main canvas (picture frame)
    let rx = FRAME_X + b.x * (FRAME_W / artCanvas.width);
    let ry = FRAME_Y + b.y * (FRAME_H / artCanvas.height);
    let rw = b.w * (FRAME_W / artCanvas.width);
    let rh = b.h * (FRAME_H / artCanvas.height);
    rect(rx, ry, rw, rh);
  }
}

function drawFlowingBlocks() {
  if (!flowActive || dayNightT < 0.4) return;

  let artToScreenX = FRAME_W / artCanvas.width;
  let artToScreenY = FRAME_H / artCanvas.height;

  const LOOP_FACTOR = 2.6;   // Control cycle distance
  const GLOBAL_SPEED = 0.25;

  for (let b of flowingBlocks) {

   // Update offset per frame (plus global speed coefficient)
  b.offset += b.speed * GLOBAL_SPEED;

  // After one cycle, loop (without exiting the screen)
  let loopRange = (b.direction === "vertical" ? b.h : b.w) * LOOP_FACTOR;
  if (b.offset > loopRange) b.offset = 0;
  let sx, sy;
  let sw = b.w * artToScreenX;
  let sh = b.h * artToScreenY;

  // Vertical
  if (b.direction === "vertical") {
    let shift = b.offset % (b.h * 1.0);

      // Original Position + Flow Offset
      let canvasY = b.y + shift;

      // Constrained within the artCanvas boundaries (does not extend beyond the frame)
      canvasY = constrain(canvasY, 0, artCanvas.height - b.h);

      sx = FRAME_X + b.x * artToScreenX;
      sy = FRAME_Y + canvasY * artToScreenY;
    }

  // Horizontal
    else {
    let shift = b.offset % (b.w * 1.0);
    let canvasX = b.x + shift;

      // Constrained within the artCanvas boundaries (does not extend beyond the frame) 
      canvasX = constrain(canvasX, 0, artCanvas.width - b.w);
      sx = FRAME_X + canvasX * artToScreenX;
      sy = FRAME_Y + b.y * artToScreenY;
    }

  // Nighttime Traffic Overlay Layer
    noStroke();
    fill(b.color);
    rect(sx, sy, sw, sh);
  }
}
  function scaleToWindow() {
  let scaleX = windowWidth / baseWidth;
  let scaleY = windowHeight / baseHeight;
  let scale = Math.max(scaleX, scaleY);
  
  let canvasElement = document.querySelector('canvas');
  canvasElement.style.position = "absolute";
  canvasElement.style.left = "50%";
  canvasElement.style.top = "50%";
  canvasElement.style.transformOrigin = "center center";
  canvasElement.style.transform = `translate(-50%, -50%) scale(${scale})`;
}
// === Day/Night overlay effect ===
  function applyDayNightFilter() {

  // Smoothly interpolate to target value
  dayNightT = lerp(dayNightT, targetDayNightT, dayNightLerpSpeed);

  // Transparency
  let darkness = map(dayNightT, 0, 1, 0, 0.65);

  // Night Blue Tint
  let blueTint = map(dayNightT, 0, 1, 0, 80);
  noStroke();
  fill(0, 50, blueTint, darkness * 255);
  rect(0, 0, width, height);
}
  // Flash Overlay (Daytime Mode)
  function drawPhotoFlash() {
  
    // Only effective in Day mode
  if (dayNightT > 0.3) return;
  if (photoFlashT <= 0) return;

  // The larger the alpha value, the brighter the image.
  let alpha = photoFlashT * 255;
  noStroke();
  fill(255, 255, 255, alpha);
  rect(0, 0, width, height);

  // Gradually darkening
  photoFlashT -= 0.08;
  if (photoFlashT < 0) photoFlashT = 0;
}
 function keyPressed() {
  if (key === 'd' || key === 'D') {
    targetDayNightT = 0;              // day
  }
  if (key === 'n' || key === 'N') {
    targetDayNightT = 1;             // night
  }
  if (key === 'm' || key === 'M') {  //M: controls the flow of small yellow road blocks
    flowActive = !flowActive;
  }

  // P: Flash for photos, only activates during daylight hours
  if (key === 'p' || key === 'P') {
    if (dayNightT < 0.3) {          
      photoFlashT = 1.0;            
      shotShake   = 1.0;           
 }
}

  // S: Nighttime Shake
if (key === 's' || key === 'S') {
  if (dayNightT > 0.4) {
    glitchActive = !glitchActive;
  }
 }
}
 function windowResized() {
  scaleToWindow();
}

  // Moonlight Effect
 function drawMoonLight() {
   if (dayNightT < 0.4) return;  
   push();

  // Layers upon layers of light rings
  for (let r = 600; r > 0; r -= 20) {
    let alpha = map(r, 0, 600, 180, 0);
    fill(255, 255, 220, alpha * 0.25);  
    noStroke();
    ellipse(moonLightX, moonLightY, r, r * 0.8);
}
    pop();
}
